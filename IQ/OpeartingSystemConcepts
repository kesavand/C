Opearting System Concepts 

Processes
what is a process ?
A process is an instance of an executing program including
the current values of the program counter, registers, and variables

What is a Thread? 
A thread is a sequence of instructions within a process that can be managed
by a scheduler.

what is the difference between process and thread ?
1. processes exists independently, while threads exist as subsets of a process
2. threads shares with other threads their code section, data section(global, global static and local static variables), heap
   and OS resources like open files and signals
3. But, like process, a thread has its own program counter (PC), 
   a register set, and a stack space.
   

   
When we should use threads in our application ?
1. Offloading a batch of work to a worker thread so your program can either 
   continue responding to user input or so you can carry on running other code
   that doesn't rely on that work.
2. Handling I/O particularly server and network communication where the response
   time is variable or unknown.
3. Parallel processing of data where you can sub-divide the work down into 
   discrete non-dependant units of work
4. Timer related work i.e 'every 500ms check if x has changed'
5. when we are using Multicore machines.


what are the types of threads ?
1. User level threads - User managed threads.
2. kernel level threads − Operating System managed threads acting on kernel, an operating system core.

There are four principal events that cause processes to be created:
1. System initialization.
2. Execution of a process creation system call by a running process.
3. A user request to create a new process.

Events that trigger process termination
1. Normal exit (voluntary).
2. Error exit (voluntary).
3. Fatal error (involuntary).
4. Killed by another process (involuntary).

How a process is created in Linux?
In UNIX, there is only one system call to create a new process: fork. This call
creates an exact clone of the calling process. After the fork, the two processes, the
parent and the child, have the same memory image, the same environment strings,
and the same open files.Usually, the child process then executes
execve or a similar system call to change its memory image and run a new
program.

what are the different states of a process ?
1. Running (actually using the CPU at that instant).
2. Ready (runnable; temporarily stopped to let another process run).
3. Blocked (unable to run until some external event happens).


what are the basic p thread calls ?
Pthread_create - Create a new thread
Pthread_exit - Terminate the calling thread
Pthread_join - Wait for a specific thread to exit
Pthread_yieid - Release the CPU to let another thread run
Pthread_attr_init - Create and initialize a thread's attribute structure
Pthread_attr_destroy - Remove a thread's attribute structure

what is re-entrant and thread safe function ?
a re-entrant function is a function that can be safely interrupted in the middle of its execution
and then safely be called again ("re-entered") before its previous invocations complete execution.
1. A reentrant function does not hold static data over successive calls
2. It should not return a pointer to static data
3. It should not call non-reentrant functions.
A threadsafe function protects shared resources from concurrent access by locks.

What are the changes to be done in the program if it has to run in multi-threading environment?
when converting a single threaded program to multi threaded the following
issues needs to be taken care.

1. gloable variables accessd by multiple threads can cause race condition.
   avoid of global variables, mutex can be used to solve this issue.
2. all the functions that can be called from multiple threads should be re-entrant

3. Usually when a process is out of stack the kernel will try to increase the stack,
   but since the user level threads are invisible to the kernel and each thread has 
   its own stack when a thread is running out of stack then it cannot be dynamically increased
   
what are the different thread synchronization mechanisms ?
semaphore
mutex
condition variables 
spinlocks
monitors


what is a semaphore ?
A semaphore is an integer whose value is never allowed to fall below zero. 
Two operations can be performed on semaphores: increment the semaphore value 
by one (sem_post(3)); and decrement the semaphore value by one (sem_wait(3)).
If the value of a semaphore is currently zero, then a sem_wait(3) operation
will block until the value becomes greater than zero.

what are the types of semaphore ?
counting semaphore - Permit a limited number of threads to execute a
critical section (producer consumer problem)
binary semaphore - section of the code - Permit only one thread to execute a section of
the critical section (mutual exclusion)
named semaphore - used between unrelated process
un-named semaphore - used between related process


what is a named semaphore ?
A named semaphore is identified by a name of the form /somename;
The name is stored in kernel space so two processes can operate on
the same named semaphore by passing the same name to sem_open(3).
 

what is unamed semaphore ?
An unnamed semaphore does not have a name.Instead the semaphore is placed in a 
region of memory that is shared between multiple threads (a thread-shared semaphore)
or processes (a process-shared semaphore).The Before being used, an unnamed semaphore 
must be initialized using sem_init(3).If the pshared argument of sem_init has a non-zero
value, then the semaphore is shared between processes otherwise the semaphore is shared 
between threads of same process.



Semaphore Operations

int sem_init(sem_t *sem, int pshared, unsigned
value);

Description:
Initialize an unnamed semaphore

Parameters:
sem - Target semaphore

pshared 
0: only threads of the creating process can use the semaphore
Non-0: other processes can use the semaphore

value:
Initial value of the semaphore

Return Value:
0 on success
-1 on failure, sets errno

int sem_destroy(sem_t *sem);

Description:
Destroy an semaphore

Parameters:
sem - Target semaphore

Return Value:
0 on success
-1 on failure, sets errno


int sem_post(sem_t *sem); 

Description:
increment the semaphore value by one
Parameters:
sem - Target Semaphore

Return Value:
0 on success
-1 on failure, sets errno (== EINVAL if semaphore doesn’t exist)

int sem_wait(sem_t *sem);
Description:
decrement the semaphore value by one,If the value of a semaphore is 
currently zero, then a sem_wait(3) operation will block until the value 
becomes greater than zero.

Parameters:
sem - Target Semaphore

Return Value:
0 on success
-1 on failure, sets errno



int sem_trywait(sem_t *sem);
Description:
Test a semaphore’s current condition

Parameters:
sem - Target Semaphore

Return Value:
0 on success
-1 on failure, sets errno
